---
title: "Бинарный поиск"
author: Denis Bakin
format: 
  beamer:
    pdf-engine: xelatex
    aspectratio: 169
    fontsize: 9pt
    section-titles: false
    incremental: false
    include-in-header: ../../files/presentation_header.tex
    theme: metropolis
lang: ru
---

# Бинарный поиск: идея

- Метод "половинного деления" — каждый раз делим область поиска пополам  
- Применяется, когда:
  - область поиска **упорядочена** (массив, диапазон)
  - или **функция монотонна**
- На каждом шаге:
  - вычисляем середину `m = (l + r) / 2`
  - решаем, в какой половине искать дальше
- Останавливаемся, когда область становится достаточно маленькой

---

# Интуиция: игра в «данетку»

- Загадано число от $1$ до $100$
- Разрешено спрашивать: «$x > m?$»
- Каждый вопрос сокращает диапазон поиска в $2$ раза

Пример:

```

x > 50? no
x > 25? yes
x > 38? yes
x > 44? no
x > 41? yes
x > 43? no
x > 42? no
x = 42

```

- 7 шагов = примерно $\log_2(100)$  
- В общем случае — $\cal{O}(\log n)$ шагов

---

# Поиск в отсортированном массиве

Пусть массив `a` отсортирован по возрастанию.

**Задача:** найти индекс элемента `x` или вернуть `-1`, если его нет.

1. Задаём `l = 0`, `r = n - 1`  
2. Находим середину `m = (l + r) / 2`  
3. Если `a[m] == x` — нашли  
4. Если `a[m] < x` — сдвигаем `l = m + 1`  
5. Если `a[m] > x` — сдвигаем `r = m - 1`  
6. Повторяем, пока `l <= r`

---

# Реализация в C++

```C++
int find(const std::vector<int>& data, int elem_to_find) {
    int l = 0, r = (int)data.size() - 1;

    while (l <= r) {
        int m = (l + r) / 2;
        if (data[m] == elem_to_find)
            return m;
        else if (data[m] < elem_to_find)
            l = m + 1;
        else
            r = m - 1;
    }
    return -1;
}
```

* Время: $\cal{O}(\log n)$
* Память: $\cal{O}(1)$
* Работает только на **отсортированных данных**

---

# Готовые функции C++ STL

* `std::lower_bound(a.begin(), a.end(), x)` — первый элемент ≥ `x`
* `std::upper_bound(a.begin(), a.end(), x)` — первый элемент > `x`
* `std::binary_search(a.begin(), a.end(), x)` — проверяет, есть ли элемент `x`

Пример:

```C++
auto it = std::lower_bound(a.begin(), a.end(), x);
if (it != a.end() && *it == x)
    std::cout << "Found\n";
```

---

# Бинарный поиск по монотонному свойству

Идея: если свойство меняется **ровно один раз**, можно найти точку перехода.

Примеры:

* Найти первый элемент, равный `x`
* Найти последнюю позицию, где $a[i] \leq x$
* Найти индекс, начиная с которого числа становятся чётными

**Главное условие:** свойство $f(i)$ монотонно
(всё $\text{false}$, потом всё $\text{true}$, или наоборот)

---

# Бинарный поиск по ответу

* Формулируем задачу как:

    **«Найти максимальное $x$, для которого выполняется свойство $P(x)$»**
* Свойство $P(x)$ монотонно:

    * если выполняется для $x$, то выполняется и для всех меньших (или наоборот)

---

# Пример: «Коровы в стойла»

> Есть $n$ стойл с координатами и $k$ коров.
> Нужно разместить коров так, чтобы **минимальное расстояние** между ними было **максимальным**.

---

# Решение через бинарный поиск по ответу

1. Сортируем координаты стойл
2. Проверяем, можно ли расставить коров на расстоянии $x$
3. Ищем **наибольшее возможное** $x$

```C++
bool check(int x) {
    int cows = 1, last = coords[0];
    for (int c : coords) {
        if (c - last >= x) {
            cows++;
            last = c;
        }
    }
    return cows >= k;
}
```

---

# Внешний бинарный поиск

```C++
int solve() {
    sort(coords.begin(), coords.end());
    int l = 0, r = coords.back() - coords[0] + 1;
    while (r - l > 1) {
        int m = (l + r) / 2;
        if (check(m))
            l = m;   // можно — увеличиваем расстояние
        else
            r = m;   // нельзя — уменьшаем
    }
    return l;
}
```

* Внутренняя проверка $\mathcal{O}(n)$
* Внешний бинпоиск $\mathcal{O}(\log X)$
* Общая сложность: $\mathcal{O}(n \log X)$

---

# Пример: «Принтеры»

> Первый принтер печатает 1 лист за $x$ минут,
> второй — за $y$ минут.
> Сколько минут потребуется, чтобы напечатать $n$ листов?

---

# Решение

Функция-предикат — «успеют ли за $t$ минут»:

```C++
bool check(long long t) {
    return (t / x) + (t / y) >= n;
}
```

Бинарный поиск по времени:

```C++
long long l = 0, r = 1LL * min(x, y) * n;
while (l + 1 < r) {
    long long m = (l + r) / 2;
    if (check(m))
        r = m;
    else
        l = m;
}
return r;
```

---

# Бинарный поиск с вещественными аргументами

Теперь аргументы — **действительные числа**, а не целые.
Пример: найти $\sqrt{2}$ из уравнения $x^2 = 2$.

Свойство:
$$
f(x) =
\begin{cases}
0, & x^2 < 2 \\
1, & x^2 \ge 2 \\
\end{cases}
$$

Монотонное — можно применить бинарный поиск.

---

# Реализация бинарного поиска для вещественных чисел

```C++
float sqrt_bin(float x) {
    float l = 0, r = x;
    for (int i = 0; i < 100; i++) {
        float m = (l + r) / 2;
        if (m * m < x)
            l = m;
        else
            r = m;
    }
    return l;
}
```

* 100 итераций ≈ точность $10^{-6}$
* Останавливаемся, когда $r - l < \varepsilon$ или по числу шагов

---

# Дихотомия для унимодальной функции

* Функция унимодальна — сначала возрастает, потом убывает
* Пример: парабола, функция прибыли по времени

**Цель:** найти $x_{\max}$, где функция достигает максимума

---

# Алгоритм дихотомии

1. Задаём начальный отрезок $[l, r]$
2. Находим две точки:
   $$
   m_1 = l + \frac{r - l}{3}, \quad
   m_2 = r - \frac{r - l}{3}
   $$
3. Если $f(m_1) < f(m_2)$ — максимум в $[m_1, r]$
4. Иначе — в $[l, m_2]$
5. Повторяем до сходимости ($r - l < \varepsilon$)

---

# Пример кода дихотомии

```C++
double ternary_search(double l, double r) {
    for (int i = 0; i < 100; i++) {
        double m1 = l + (r - l) / 3;
        double m2 = r - (r - l) / 3;
        if (f(m1) < f(m2))
            l = m1;
        else
            r = m2;
    }
    return (l + r) / 2;
}
```

* Работает для **унимодальных функций**
* Находит **точку экстремума** (обычно максимум)
* Время: $\cal{O}(\log \varepsilon)$** по требуемой точности

---

# Сравнение подходов

| Тип задачи         | Что ищем                          | Аргументы    | Пример               |
| ------------------ | --------------------------------- | ------------ | -------------------- |
| Бинарный поиск     | индекс/значение                   | целые        | поиск в массиве      |
| Бинпоиск по ответу | максимальный/минимальный параметр | целые        | «коровы», «принтеры» |
| Дихотомия          | максимум/минимум функции          | вещественные | унимодальные функции |
